```
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        result = []
        carry = 0
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            # 获取当前位的数字，如果越界则为0
            digit_a = int(a[i]) if i >= 0 else 0
            digit_b = int(b[j]) if j >= 0 else 0
            
            # 计算当前位的和
            total = digit_a + digit_b + carry
            
            # 添加当前位到结果
            result.append(str(total % 2))
            
            # 计算进位
            carry = total // 2
            
            # 移动指针
            i -= 1
            j -= 1
        
        # 反转结果并返回
        return ''.join(reversed(result))
```

最初自己写的方法, 笨拙但是效率更高
```
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        m,n=len(a),len(b)
        res=[]
        carry=0
        for i in range(min(m, n)):
            curr = carry + int(a[m-1-i]) + int(b[n-1-i]) # 这里是一个坑,容易忽略对齐,所以不能倒叙用没有对齐的i
            if curr==2:
                res.append("0") # res:1,0,1,0
                carry=1
            elif curr == 3: #进位有存在是3的情况
                res.append('1') 
                carry=1
            else:
                res.append(str(curr))  # Append the sum ('0' or '1') to the result
                carry = 0
        if m>n:
            left=a[:m-n]
        else:
            left=b[:n-m]
        
        for i in range(len(left)-1,-1,-1):
            curr = carry + int(left[i])
            if curr==2:
                res.append("0") 
                carry=1     # res:1,0,1,0,1
            elif curr == 3:
                res.append('1') 
                carry=1
            else:
                res.append(str(curr))  
                carry = 0

        if carry == 1:
            res.append('1')
        res.reverse()
        return "".join(res)
```

