## 🔍 红蓝染色法（Red-Blue Coloring Method）

这是二分查找的一个直观思维方式，把数组（或者区间）中的元素分成两类：

- 🔴 **红色**（不满足条件）  
- 🔵 **蓝色**（满足条件）

这个方法假设数组（或者判断条件）是**单调的**，比如所有红色在左，所有蓝色在右，**没有交叉**。

---

🎯 **目标：**  
找到红区和蓝区的**分界线**（也就是状态从不满足变为满足的位置）。

这条分界线就是我们要找的**边界索引**。


方法1 闭区间写法 [left, right]

"""
from typing import List

def lower_bound(nums: List[int], target: int) -> int:
    # 如果目标值不存在，返回 len(nums)
    left = 0
    right = len(nums) - 1  # 区间是闭区间 [left, right]
    while left <= right:  # 当区间不为空时循环
        mid = (left + right) // 2  # 取中点索引
        if nums[mid] < target:
            left = mid + 1  # 目标在右半区间 [mid+1, right]
        else:
            right = mid - 1  # 目标在左半区间 [left, mid-1]
    return left  # 返回左边界索引

"""

方法2 左闭右开区间 [left, right)

"""
from typing import List

def lower_bound2(nums: List[int], target: int) -> int:
    left = 0
    right = len(nums)  # 左闭右开区间 [left, right)
    while left < right:  # 区间不为空
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1  # [mid+1, right)
        else:
            right = mid  # [left, mid)
    return left  # 返回第一个大于等于target的位置
"""


方法3 开区间写法 (left, right)

"""
def lower_bound3(nums: List[int], target: int) -> int:
    left = -1
    right = len(nums)  # 开区间 (left, right)
    while left + 1 < right:  # 区间不为空
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid  # (mid, right)
        else:
            right = mid  # (left, mid)
    return right  # 返回第一个大于等于target的位置
"""
